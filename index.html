<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> de Excel</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Carga de la biblioteca SheetJS (xlsx.js) para leer archivos de Excel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Carga de nueva fuente 'Inter' (formal) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            /* Cambio de fuente a Inter (sans-serif) */
            font-family: 'Inter', sans-serif;
        }
        /* Estilos para la tabla de frecuencia con nuevos colores */
        .freq-table {
            width: 100%;
            border-collapse: collapse;
        }
        .freq-table th, .freq-table td {
            border: 1px solid #e2e8f0; /* slate-200 */
            padding: 8px 12px;
            text-align: left;
        }
        .freq-table th {
            background-color: #f1f5f9; /* slate-100 */
            font-weight: 600;
        }
        .freq-table tr:nth-child(even) {
            background-color: #f8fafc; /* slate-50 */
        }
        /* Estilo para deshabilitar selectores */
        select:disabled {
            background-color: #f1f5f9; /* slate-100 */
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-slate-100 min-h-screen flex items-center justify-center p-4">

    <div class="bg-white w-full max-w-4xl p-6 sm:p-8 rounded-xl shadow-lg">
        
        <h1 class="text-2xl sm:text-3xl font-bold text-center text-slate-800 mb-6">
            Analizador de Datos de Excel
        </h1>

        <p class="text-center text-slate-600 mb-6">
            Sube tu archivo .xlsx o .xls para analizar los datos.
        </p>

        <!-- Sección de carga de archivo (nuevos colores) -->
        <div class="flex flex-col items-center space-y-4 mb-8">
            <input type="file" id="fileInput"
                class="block w-full max-w-md text-sm text-slate-500
                file:mr-4 file:py-2 file:px-4
                file:rounded-lg file:border-0
                file:text-sm file:font-semibold
                file:bg-slate-100 file:text-slate-700
                hover:file:bg-slate-200"
                accept=".xlsx, .xls">
            
            <button id="processButton" 
                class="w-full max-w-md bg-slate-700 text-white font-bold py-3 px-6 rounded-lg shadow-md
                       hover:bg-slate-800 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50
                       transition-colors duration-200">
                Procesar Archivo
            </button>
        </div>

        <!-- CORRECCIÓN: Área de mensajes (re-insertada) -->
        <div id="messageArea" class="text-center text-slate-600 my-4"></div>
        
        <!-- CORRECCIÓN: Controles de Filtro (re-insertados) -->
        <div id="filterControls" class="hidden bg-slate-50 p-4 rounded-lg shadow-inner mb-6 grid grid-cols-1 sm:grid-cols-3 gap-4">
            <div>
                <label for="analysisType" class="block text-sm font-medium text-slate-700 mb-1">Tipo de Análisis</label>
                <select id="analysisType" class="w-full rounded-md border-slate-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                    <option value="total" selected>Total General</option>
                    <option value="periodo">Análisis por Periodo (Mensual y Acumulado)</option>
                </select>
            </div>
            <div>
                <label for="yearSelect" class="block text-sm font-medium text-slate-700 mb-1">Año</label>
                <select id="yearSelect" class="w-full rounded-md border-slate-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500" disabled>
                    <!-- Opciones de año se llenarán dinámicamente -->
                </select>
            </div>
            <div>
                <label for="monthSelect" class="block text-sm font-medium text-slate-700 mb-1">Mes</label>
                <select id="monthSelect" class="w-full rounded-md border-slate-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500" disabled>
                    <!-- Opciones de mes se llenarán dinámicamente -->
                </select>
            </div>
        </div>

        <!-- NUEVO: Contenedor del Botón de Exportación -->
        <!-- CAMBIO: Añadido mb-8 para dar espacio inferior -->
        <div id="exportContainer" class="hidden text-center mt-6 mb-8">
            <!-- BOTÓN MODIFICADO: Más estético con icono SVG -->
            <!-- CAMBIO: Eliminadas clases 'w-full' y 'max-w-md' para ajustar al texto -->
            <button id="exportButton"
                class="inline-flex items-center justify-center gap-2 bg-green-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md
                       hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50
                       transition-colors duration-200">
                <!-- Icono SVG de descarga -->
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                </svg>
                <!-- CAMBIO: Texto del botón -->
                Exportar
            </button>
        </div>

        <!-- Contenedor de resultados -->
        <!-- Este contenedor se llenará dinámicamente con JavaScript -->
        <div id="resultsArea" class="hidden space-y-8">
            
            <!-- Los resultados agrupados se insertarán aquí -->

        </div>

    </div>

    <script>
        document.getElementById('processButton').addEventListener('click', handleFile);
        
        // NUEVO: Añadir event listeners para los filtros
        document.getElementById('analysisType').addEventListener('change', runAnalysis);
        document.getElementById('yearSelect').addEventListener('change', runAnalysis);
        document.getElementById('monthSelect').addEventListener('change', runAnalysis);
        // NUEVO: Listener para el botón de exportar
        document.getElementById('exportButton').addEventListener('click', exportResultsToExcel);


        // NUEVO: Variable global para almacenar todos los datos leídos
        let allDataRows = [];
        // NUEVO: Variable global para guardar los datos para exportación
        let exportableData = {}; 
        const COL_B_INDEX = 1; // Columna B (Fecha de Pago)

        // Definición de meses para el selector
        const monthNames = [
            "Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
            "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"
        ];

        function handleFile() {
            const fileInput = document.getElementById('fileInput');
            const messageArea = document.getElementById('messageArea');
            const resultsArea = document.getElementById('resultsArea');
            const filterControls = document.getElementById('filterControls');
            // NUEVO: Ocultar botón de exportar
            const exportContainer = document.getElementById('exportContainer');
            const file = fileInput.files[0];

            // Limpiar mensajes y resultados anteriores
            messageArea.textContent = '';
            resultsArea.classList.add('hidden');
            resultsArea.innerHTML = ''; // Limpiar contenido HTML anterior
            filterControls.classList.add('hidden'); // Ocultar filtros
            exportContainer.classList.add('hidden'); // Ocultar exportación
            allDataRows = []; // Limpiar datos anteriores
            exportableData = {}; // Limpiar datos de exportación

            if (!file) {
                messageArea.textContent = 'Por favor, selecciona un archivo de Excel.';
                messageArea.classList.add('text-red-500');
                messageArea.classList.remove('text-green-600');
                return;
            }

            messageArea.textContent = 'Procesando archivo...';
            messageArea.classList.remove('text-red-500', 'text-green-600');
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    // NUEVO: 'cellDates: true' para que SheetJS parsee las fechas de Excel a objetos Date
                    const workbook = XLSX.read(data, { type: 'array', cellDates: true });

                    // Obtener la primera hoja del libro
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];

                    // Convertir la hoja a JSON (array de arrays)
                    // header: 1 indica que la salida es un array de arrays
                    const jsonRows = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                    // NUEVO: Guardar datos en la variable global
                    allDataRows = jsonRows;

                    // NUEVO: Poblar los filtros de fecha
                    populateDateFilters(allDataRows);
                    
                    // NUEVO: Mostrar controles de filtro
                    filterControls.classList.remove('hidden');

                    // NUEVO: Ejecutar el análisis inicial (Total General)
                    runAnalysis();

                    messageArea.textContent = '¡Archivo procesado con éxito!';
                    messageArea.classList.remove('text-red-500');
                    messageArea.classList.add('text-green-600');
                    // resultsArea.classList.remove('hidden'); // runAnalysis se encargará de esto

                } catch (error) {
                    console.error("Error al leer el archivo:", error);
                    messageArea.textContent = 'Error al leer el archivo. Asegúrate de que sea un archivo de Excel válido.';
                    messageArea.classList.add('text-red-500');
                    messageArea.classList.remove('text-green-600');
                }
            };

            reader.onerror = function(e) {
                console.error("Error de FileReader:", e);
                messageArea.textContent = 'Ocurrió un error al leer el archivo.';
                messageArea.classList.add('text-red-500');
                messageArea.classList.remove('text-green-600');
            };

            reader.readAsArrayBuffer(file);
        }

        /**
         * NUEVA FUNCIÓN: Popula los selectores de Año y Mes
         * basándose en las fechas encontradas en la Columna B.
         */
        function populateDateFilters(rows) {
            const yearSelect = document.getElementById('yearSelect');
            const monthSelect = document.getElementById('monthSelect');
            const availableYears = new Set();
            
            // Empezar desde la fila 1 para omitir el encabezado
            for (let i = 1; i < rows.length; i++) {
                const row = rows[i];
                const date = row[COL_B_INDEX];

                // Verificar si es un objeto Date válido
                if (date instanceof Date && !isNaN(date)) {
                    availableYears.add(date.getFullYear());
                }
            }

            // Limpiar selectores
            yearSelect.innerHTML = '';
            monthSelect.innerHTML = '';

            // Poblar selector de Mes (siempre 1-12)
            monthNames.forEach((name, index) => {
                const monthValue = index + 1; // 1-12
                monthSelect.innerHTML += `<option value="${monthValue}">${name}</option>`;
            });

            // Poblar selector de Año
            if (availableYears.size === 0) {
                yearSelect.innerHTML = '<option value="">Sin Años</option>';
                yearSelect.disabled = true;
                monthSelect.disabled = true;
                return;
            }

            const sortedYears = Array.from(availableYears).sort((a, b) => b - a); // Más reciente primero
            sortedYears.forEach(year => {
                yearSelect.innerHTML += `<option value="${year}">${year}</option>`;
            });

            yearSelect.disabled = false;
            monthSelect.disabled = false;
        }

        /**
         * NUEVA FUNCIÓN: Filtra los datos globales según los selectores
         * y luego llama a processData.
         */
        function runAnalysis() {
            const resultsArea = document.getElementById('resultsArea');
            const analysisType = document.getElementById('analysisType').value;
            const yearSelect = document.getElementById('yearSelect');
            const monthSelect = document.getElementById('monthSelect');
            
            // NUEVO: Referencia al contenedor de exportación
            const exportContainer = document.getElementById('exportContainer');

            // Habilitar/deshabilitar selectores de fecha
            if (analysisType === 'total') {
                yearSelect.disabled = true;
                monthSelect.disabled = true;
            } else { // 'periodo'
                yearSelect.disabled = false;
                monthSelect.disabled = false;
            }

            if (allDataRows.length === 0) return; // No hay datos para procesar

            // ***** MASTER CLEAR *****
            // Limpiar resultados ANTES de cualquier lógica
            resultsArea.innerHTML = ''; 
            // NUEVO: Limpiar datos de exportación
            exportableData = {};

            const headerRow = allDataRows[0];

            if (analysisType === 'total') {
                // Lógica original para "Total General"
                const filteredRows = allDataRows.slice(1);
                const groupedData = processData([headerRow, ...filteredRows]);
                renderGroupedData(groupedData, resultsArea);
                // NUEVO: Guardar datos para exportar
                exportableData = { "Total_General": groupedData };

            } else { // Lógica NUEVA para "periodo" (Mensual + Acumulado)
                
                // Obtener valores de fecha para filtrar
                const selectedYear = parseInt(yearSelect.value, 10);
                const selectedMonth = parseInt(monthSelect.value, 10); // 1-12

                if (!selectedYear) {
                    resultsArea.innerHTML = '<p class="text-center text-red-500">No hay un año válido seleccionado.</p>';
                    resultsArea.classList.remove('hidden');
                    return;
                }

                // --- 1. ANÁLISIS MENSUAL ---
                resultsArea.innerHTML += `<h2 class="text-3xl font-bold text-center text-slate-800 mb-6">Análisis Mensual (${monthNames[selectedMonth-1]} ${selectedYear})</h2>`;
                
                const monthlyFilteredRows = allDataRows.slice(1).filter(row => {
                    const date = row[COL_B_INDEX];
                    if (!(date instanceof Date) || isNaN(date)) {
                        return false; // Ignorar filas sin fecha válida
                    }
                    const rowYear = date.getFullYear();
                    const rowMonth = date.getMonth() + 1; // JS getMonth es 0-11, +1 para 1-12
                    return rowYear === selectedYear && rowMonth === selectedMonth;
                });

                const monthlyGroupedData = processData([headerRow, ...monthlyFilteredRows]);
                renderGroupedData(monthlyGroupedData, resultsArea); // Renderizar (append)

                // --- 2. DIVIDER ---
                resultsArea.innerHTML += '<hr class="my-12 border-t-2 border-slate-300">';

                // --- 3. ANÁLISIS ACUMULADO ---
                resultsArea.innerHTML += `<h2 class="text-3xl font-bold text-center text-slate-800 mb-6">Análisis Acumulado (Hasta ${monthNames[selectedMonth-1]} ${selectedYear})</h2>`;
                
                const cumulativeFilteredRows = allDataRows.slice(1).filter(row => {
                    const date = row[COL_B_INDEX];
                    if (!(date instanceof Date) || isNaN(date)) {
                        return false; // Ignorar filas sin fecha válida
                    }
                    const rowYear = date.getFullYear();
                    const rowMonth = date.getMonth() + 1; // JS getMonth es 0-11, +1 para 1-12
                    return rowYear === selectedYear && rowMonth <= selectedMonth;
                });
                
                const cumulativeGroupedData = processData([headerRow, ...cumulativeFilteredRows]);
                renderGroupedData(cumulativeGroupedData, resultsArea); // Renderizar (append)

                // NUEVO: Guardar ambos grupos de datos para exportar
                exportableData = {
                    "Mensual": monthlyGroupedData,
                    "Acumulado": cumulativeGroupedData
                };
            }

            // Mostrar el área de resultados al final
            resultsArea.classList.remove('hidden');
            // NUEVO: Mostrar el botón de exportar
            if (Object.keys(exportableData).length > 0) {
                exportContainer.classList.remove('hidden');
            }
        }


        function processData(rows) {
            const groupedData = {}; // Estructura para agrupar los datos

            // Columnas (índice basado en 0)
            const COL_A_INDEX = 0;  // Columna A (para la condición)
            const COL_D_INDEX = 3;  // Columna D (Tipo de Seguro)
            const COL_O_INDEX = 14; // Columna O
            const COL_Q_INDEX = 16; // Columna Q
            const COL_AA_INDEX = 26; // Columna AA (Unidades Indemnizadas)
            const COL_AC_INDEX = 28; // Columna AC (Indemnización)


            // Empezar desde la fila 1 para omitir el encabezado (índice 0)
            for (let i = 1; i < rows.length; i++) {
                const row = rows[i];
                
                // Normalizar valores de Col A y Col D
                const valA_raw = row[COL_A_INDEX];
                const valD_raw = row[COL_D_INDEX];
                const valA = (valA_raw === null || valA_raw === undefined) ? '' : String(valA_raw).trim();
                const valD = (valD_raw === null || valD_raw === undefined || String(valD_raw).trim() === '') ? '(Sin Tipo)' : String(valD_raw).trim();


                // 1. Determinar el grupo efectivo (LÓGICA ACTUALIZADA)
                let effectiveTipoSeguro;
                let ejercicioLabel = valA; // La etiqueta será el valor de la Col A

                if (valA === '2025-2026') {
                    effectiveTipoSeguro = 'SEGUROS COMERCIALES (2025-2026)';
                } else if (valA === '2024-2025') {
                    effectiveTipoSeguro = 'SEGUROS COMERCIALES (2024-2025)';
                } else {
                    effectiveTipoSeguro = valD;
                    if (valA === '') ejercicioLabel = '(Sin Ejercicio)';
                }


                // Inicializar el grupo si no existe
                if (!groupedData[effectiveTipoSeguro]) {
                    groupedData[effectiveTipoSeguro] = {
                        colO: {},
                        colQ: {},
                        count: 0, // Contador para el total de este grupo
                        sumAA: 0, // Suma para Columna AA
                        sumAC: 0, // Suma para Columna AC
                        ejercicio: ejercicioLabel // NUEVO: Guardar la etiqueta del ejercicio
                    };
                }
                
                // Aumentar el contador para este tipo de seguro
                groupedData[effectiveTipoSeguro].count++;

                // 2. Frecuencia Columna Q (para este grupo)
                let valQ = row[COL_Q_INDEX];
                if (valQ === null || valQ === undefined || String(valQ).trim() === '') {
                    valQ = '(Vacío)'; // Agrupar valores vacíos
                }
                valQ = String(valQ).trim();
                groupedData[effectiveTipoSeguro].colQ[valQ] = (groupedData[effectiveTipoSeguro].colQ[valQ] || 0) + 1;


                // 3. Frecuencia Columna O (para este grupo)
                let valO = row[COL_O_INDEX];
                if (valO === null || valO === undefined || String(valO).trim() === '') {
                    valO = '(Vacío)'; // Agrupar valores vacíos
                }
                valO = String(valO).trim();
                groupedData[effectiveTipoSeguro].colO[valO] = (groupedData[effectiveTipoSeguro].colO[valO] || 0) + 1;

                // 4. Sumar Columna AA y AC
                // Convertir a número, o 0 si está vacío/no es número
                const valAA = parseFloat(row[COL_AA_INDEX]) || 0;
                const valAC = parseFloat(row[COL_AC_INDEX]) || 0;

                groupedData[effectiveTipoSeguro].sumAA += valAA;
                groupedData[effectiveTipoSeguro].sumAC += valAC;
            }

            // CAMBIO: Ya no renderiza, solo devuelve los datos
            // renderGroupedData(groupedData);
            return groupedData;
        }

        // CAMBIO: Acepta 'resultsArea' como parámetro y AÑADE contenido (append)
        function renderGroupedData(groupedData, resultsArea) {
            // const resultsArea = document.getElementById('resultsArea'); // Ya no se define aquí
            // resultsArea.innerHTML = ''; // Se movió a runAnalysis()

            // NUEVO: Ordenamiento personalizado
            const sortOrder = [
                "ALTA MORTALIDAD COBERTURA LIMITADA",
                "ATAQUE DE DEPREDADOR COBERTURA LIMITADA",
                "GANADERO POR DAÑOS CLIMATOLÓGICOS COBERTURA LIMITADA",
                "SEGUROS COMERCIALES (2025-2026)",
                "SEGUROS COMERCIALES (2024-2025)"
            ];

            const sortedGroups = Object.entries(groupedData).sort(([keyA], [keyB]) => {
                // Normalizar keys para comparar (ignorando mayúsculas/minúsculas)
                const keyA_upper = keyA.toUpperCase();
                const keyB_upper = keyB.toUpperCase();

                const indexA = sortOrder.indexOf(keyA_upper);
                const indexB = sortOrder.indexOf(keyB_upper);

                // Usar Infinity para items que no están en la lista, para que se vayan al final
                const sortValA = (indexA === -1) ? Infinity : indexA;
                const sortValB = (indexB === -1) ? Infinity : indexB;

                // Si los valores de orden son distintos, usarlos
                if (sortValA !== sortValB) {
                    return sortValA - sortValB;
                }

                // Si ambos no están en la lista (Infinity vs Infinity)
                // ordenarlos alfabéticamente por su llave original
                return keyA.localeCompare(keyB);
            });


            if (sortedGroups.length === 0) {
                // CAMBIO: Añade (append) el mensaje en lugar de sobrescribir
                resultsArea.innerHTML += '<p class="text-center text-slate-500">No se encontraron datos para agrupar (según el filtro aplicado).</p>';
                return;
            }

            // NUEVO: Paleta de colores profesional para los bordes
            const colorPalette = [
                'border-t-indigo-600',
                'border-t-sky-600',
                'border-t-emerald-600',
                'border-t-amber-600',
                'border-t-rose-600'
            ];

            // CAMBIO: Añadido 'index' al bucle
            for (let i = 0; i < sortedGroups.length; i++) {
                const [tipoSeguro, data] = sortedGroups[i];
                // NUEVO: Asignar un color delA paleta
                const colorClass = colorPalette[i % colorPalette.length];

                const groupHtml = `
                    <!-- CAMBIO: Añadida la clase de color y 'border-t-4' -->
                    <div class="bg-white p-6 rounded-lg shadow-lg border border-slate-200 ${colorClass} border-t-4">
                        <!-- Encabezado del Grupo (NUEVO DISEÑO) -->
                        <div class="flex flex-col sm:flex-row justify-between sm:items-center mb-4 pb-4 border-b border-slate-200 gap-4">
                            <!-- Título y Etiqueta de Ejercicio -->
                            <div class="flex flex-col gap-2">
                                <h2 class="text-2xl font-bold text-indigo-900 break-words">
                                    ${escapeHTML(tipoSeguro)}
                                </h2>
                                <!-- NUEVA ETIQUETA DE EJERCICIO -->
                                <span class="text-sm font-medium text-slate-600 bg-slate-100 px-3 py-1 rounded-full w-fit">
                                    Ejercicio: ${escapeHTML(data.ejercicio)}
                                </span>
                            </div>
                            
                            <!-- Total Avisos (NUEVO TEXTO Y DISEÑO) -->
                            <span class="text-lg sm:text-xl font-semibold text-slate-700 bg-slate-100 px-4 py-2 rounded-lg text-center sm:text-left flex-shrink-0">
                                Avisos Indemnizados: ${data.count}
                            </span>
                        </div>

                        <!-- Sección de Sumatorias (NUEVOS COLORES) -->
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6 p-4 bg-slate-50 rounded-lg border border-slate-200">
                            <div>
                                <!-- CAMBIO: Eliminado (AA) -->
                                <h3 class="text-md font-semibold text-slate-600">Total Unidades Indemnizadas</h3>
                                <p class="text-2xl font-bold text-green-800">
                                    ${data.sumAA.toLocaleString('es-ES')}
                                </p>
                            </div>
                            <div>
                                <!-- CAMBIO: Eliminado (AC) -->
                                <h3 class="text-md font-semibold text-slate-600">Total Indemnización</h3>
                                <p class="text-2xl font-bold text-green-800">
                                    ${data.sumAC.toLocaleString('es-ES')}
                                </p>
                            </div>
                        </div>

                        <!-- Contenido del Grupo (Frecuencias O y Q) -->
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <!-- Columna O -->
                            <div>
                                <h3 class="text-lg font-semibold text-slate-700 mb-3">Estado</h3>
                                <div class="max-h-64 overflow-y-auto">
                                    ${createFrequencyTable(data.colO)}
                                </div>
                            </div>
                            <!-- Columna Q -->
                            <div>
                                <h3 class="text-lg font-semibold text-slate-700 mb-3">Causa de Siniestro</h3>
                                <div class="max-h-64 overflow-y-auto">
                                    ${createFrequencyTable(data.colQ)}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                // CAMBIO: Añade (append) el HTML en lugar de sobrescribir
                resultsArea.innerHTML += groupHtml;
            }
        }

        // =======================================================
        // NUEVAS FUNCIONES PARA EXPORTAR A EXCEL
        // =======================================================

        /**
         * Función principal para exportar los resultados a Excel.
         * Lee los datos de 'exportableData' y construye un libro.
         */
        function exportResultsToExcel() {
            if (Object.keys(exportableData).length === 0) {
                alert("No hay datos para exportar.");
                return;
            }

            const wb = XLSX.utils.book_new(); // Crear un nuevo libro de Excel

            // Recorrer los tipos de análisis (ej. "Mensual", "Acumulado" o "Total_General")
            for (const analysisName in exportableData) {
                const groupedData = exportableData[analysisName];

                // Replicar la lógica de ordenamiento de renderGroupedData
                const sortOrder = [
                    "ALTA MORTALIDAD COBERTURA LIMITADA",
                    "ATAQUE DE DEPREDADOR COBERTURA LIMITADA",
                    "GANADERO POR DAÑOS CLIMATOLÓGICOS COBERTURA LIMITADA",
                    "SEGUROS COMERCIALES (2025-2026)",
                    "SEGUROS COMERCIALES (2024-2025)"
                ];

                const sortedGroups = Object.entries(groupedData).sort(([keyA], [keyB]) => {
                    const keyA_upper = keyA.toUpperCase();
                    const keyB_upper = keyB.toUpperCase();
                    const indexA = sortOrder.indexOf(keyA_upper);
                    const indexB = sortOrder.indexOf(keyB_upper);
                    const sortValA = (indexA === -1) ? Infinity : indexA;
                    const sortValB = (indexB === -1) ? Infinity : indexB;
                    if (sortValA !== sortValB) {
                        return sortValA - sortValB;
                    }
                    return keyA.localeCompare(keyB);
                });

                // Crear una hoja de cálculo para CADA grupo (ej. "Mensual - ALTA MORTALIDAD...")
                for (const [tipoSeguro, data] of sortedGroups) {
                    
                    // 1. Crear el nombre de la hoja (limpio y truncado)
                    let sheetNamePrefix = analysisName === "Total_General" ? "" : `${analysisName} - `;
                    let sheetName = sanitizeSheetName(`${sheetNamePrefix}${tipoSeguro}`);
                    
                    // 2. Construir los datos de la hoja (Array de Arrays)
                    const aoa = [];
                    
                    aoa.push([tipoSeguro]); // Título
                    aoa.push([`Ejercicio: ${data.ejercicio}`]);
                    aoa.push([`Avisos Indemnizados: ${data.count}`]);
                    aoa.push([]); // Fila vacía
                    aoa.push(["Concepto", "Total"]);
                    // CORRECCIÓN: Eliminados comentarios HTML de esta sección
                    aoa.push(["Total Unidades Indemnizadas", data.sumAA]);
                    aoa.push(["Total Indemnización", data.sumAC]);
                    aoa.push([]); // Fila vacía

                    // 3. Añadir tabla de frecuencia O
                    aoa.push(["Estado"]);
                    aoa.push(["Valor", "Frecuencia"]);
                    aoa.push(...createFrequencyData(data.colO)); // Añadir filas de datos
                    aoa.push([]); // Fila vacía
                    
                    // 4. Añadir tabla de frecuencia Q
                    aoa.push(["Causa de Siniestro"]);
                    aoa.push(["Valor", "Frecuencia"]);
                    aoa.push(...createFrequencyData(data.colQ)); // Añadir filas de datos

                    // 5. Crear la hoja y añadirla al libro
                    const ws = XLSX.utils.aoa_to_sheet(aoa);
                    XLSX.utils.book_append_sheet(wb, ws, sheetName);
                }
            }

            // 6. Descargar el archivo
            XLSX.writeFile(wb, "Analisis_Resultados.xlsx");
        }

        /**
         * Helper para convertir un mapa de frecuencia en un array de arrays
         * para 'aoa_to_sheet'.
         */
        function createFrequencyData(freqMap) {
            const sortedEntries = Object.entries(freqMap).sort(([, countA], [, countB]) => countB - countA);

            if (sortedEntries.length === 0) {
                return [["No se encontraron datos.", ""]];
            }
            // Mapea a [valor, cuenta]
            return sortedEntries.map(([value, count]) => [value, count]);
        }

        /**
         * Helper para limpiar el nombre de una hoja de Excel
         * (limita a 31 caracteres y elimina caracteres no válidos).
         */
        function sanitizeSheetName(name) {
            const invalidChars = /[\[\]\*?\/\\]/g;
            let sanitized = name.replace(invalidChars, '');
            // Limitar a 31 caracteres
            return sanitized.substring(0, 31);
        }


        function createFrequencyTable(freqMap) {
            // Convertir el mapa a un array, ordenar por frecuencia (descendente)
            const sortedEntries = Object.entries(freqMap).sort(([, countA], [, countB]) => countB - countA);

            if (sortedEntries.length === 0) {
                return '<p class="text-slate-500">No se encontraron datos.</p>';
            }

            let tableHTML = '<table class="freq-table">';
            tableHTML += '<thead><tr><th>Valor</th><th>Frecuencia</th></tr></thead>';
            tableHTML += '<tbody>';

            for (const [value, count] of sortedEntries) {
                tableHTML += `<tr>
                                <td>${escapeHTML(value)}</td>
                                <td>${count}</td>
                              </tr>`;
            }

            tableHTML += '</tbody></table>';
            return tableHTML;
        }

        function escapeHTML(str) {
            // Añadida validación para asegurar que str sea un string
            if (typeof str !== 'string') {
                str = String(str);
            }
            return str.replace(/[&<>"']/g, function(m) {
                return {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                }[m];
            });
        }
    </script>
</body>
</html>

